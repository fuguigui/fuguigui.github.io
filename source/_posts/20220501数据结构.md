---
title: Google上岸算法刷题计划表
date: 2022-06-05
tags: [Algorithm, Coding]
categories: [Sharing]
top: true
---

# 目录

- [x] **重点散列表**：总结各种巧妙的应用，以及利用了散列表什么样的特点

- [x] 栈和队列的使用，python包的使用

- [x] 堆系统性学习

- [x] 排序算法总结 （05/16）
  
  - [x] 排序算法，经典算法的要点在于什么？
  - [x] 排序算法刷题

- [x] 搜索/二分搜索（05/20）

- [x] 树：实现下，前中后序遍历 （05/21-05/28）
  
  - [x] 广搜深搜总结错题集 
  - [x] 线段树
  - [x] dfs+memo

- [x] 图：实现 
  
  - [x] topology sort

- [x] 递归/动态规划，区分不同，以及重点题目总结 

- [x] 链表和数组 

- [x] 双指针

- [x] 贪心

- [x] 内存作为新知识点进行学习

- [x] 位操作的应用实例

- [x] 专项总结：这个topic的典型应用场景有哪些？模板是什么？精选例题+每道题可以怎样follow up？
  
  - [x] 不同场景降低时间复杂度的方法有哪些 

- [x] 谷歌专项刷题：先说不做，把所有该说的都说完，想follow up，和behaviro的准备同时进行，穿插着来

- [x] labuladong每个专题刷典型题

务必掌握它们的具体用法、实现方法、应用场景以及时间和空间复杂度

各种数据结构：重要的一点是使用：适用于什么场景，时间空间复杂度是什么？典型的应用有哪些。一定要弄清楚什么情况下该使用什么数据结构。

| 数据结构                     | 算法         | 其他                |
| ------------------------ | ---------- | ----------------- |
| 链表：双指针                   | 广度优先搜索     | 位操作               |
| 树、二叉树、单词查找树，segment tree | 深度优先搜索     | 内存（堆和栈）           |
| 栈和队列                     | 二分查找       | LRUCache、LFUCache |
| 堆                        | 排序：快排，归并，桶 | 大o时间和空间           |
| 向量/数组列表/字符串              | 分治法        | 并查集               |
| 散列表                      | 滑动窗口       | 面向对象设计            |
| 图                        | 贪心算法       | 系统设计与可扩展性         |
|                          | 动态规划、递归    | 线程与锁              |

## 参考资料

- [LeetCode Cookbook](https://books.halfrost.com/leetcode/ChapterTwo/Stack/)（数据结构+算法）

- [GitHub - LeetCode 101](https://github.com/changgyhub/leetcode_101)（侧重于算法）

- [宫水三叶](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488290&idx=1&sn=a9c525e36211710e0ff480e3300e346b&chksm=fd9cb83dcaeb312b004aff26e5448bf7f77a318efab4637c33f52edd2c9e4d8b4cc3b4a63e2c&cur_album_id=1751702161341628417&scene=189#wechat_redirect)

- [dowalle](https://dowalle.gitbook.io/algo/algorithm/4-tu-lun/1-ji-ben-zhi-shi)

- [labuladong](https://labuladong.github.io/algo/3/23/71/)

- 程序员面试金典（数据结构+算法）

# 笔记链接

## 基础

[散列表](https://github.com/fuguigui/leetcode-notes/blob/master/%E6%95%A3%E5%88%97%E8%A1%A8Hash.ipynb)

[栈和队列（一：栈）](https://github.com/fuguigui/leetcode-notes/blob/master/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%9A%E6%A0%88%EF%BC%89.ipynb)

[栈和队列（二：队列）](https://github.com/fuguigui/leetcode-notes/blob/master/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%9A%E9%98%9F%E5%88%97%EF%BC%89.ipynb)

[堆](https://github.com/fuguigui/leetcode-notes/blob/master/%E5%A0%86.ipynb)

[排序算法理论](2022-05-16排序算法.md)

[排序算法力扣](https://github.com/fuguigui/leetcode-notes/blob/master/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.ipynb)

[二分搜索](https://github.com/fuguigui/leetcode-notes/blob/master/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2.ipynb)

[树和图（一：树）](https://github.com/fuguigui/leetcode-notes/blob/master/%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%88%E4%B8%80%EF%BC%9A%E6%A0%91%EF%BC%89.ipynb)

[树和图（二：树的进阶）](https://github.com/fuguigui/leetcode-notes/blob/master/%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%88%E4%BA%8C%EF%BC%9A%E6%A0%91%E7%9A%84%E8%BF%9B%E9%98%B6%EF%BC%89.ipynb)

[树和图（三：图）](https://github.com/fuguigui/leetcode-notes/blob/master/%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%88%E4%B8%89%EF%BC%9A%E5%9B%BE%EF%BC%89.ipynb)

[动态规划](https://github.com/fuguigui/leetcode-notes/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.ipynb)

## 专题

[专题BFS和DFS](https://github.com/fuguigui/leetcode-notes/blob/master/%E4%B8%93%E9%A2%98BFS%E5%92%8CDFS.ipynb)

## 综合

# 坑

python的字典复制，有几种方法，复制程度不一样

[Python dictionary字典的复制方法_小桔帽的博客-CSDN博客_python复制字典](https://blog.csdn.net/u010895119/article/details/79418434)

- `dict1=dict2`，这个只是换个名字而已，并不能叫复制，对`dict1`做的操作，都会出现在`dict2`上

- `dict1=dict2.copy()`，这个是浅复制：复制后对原dict的内部子对象(方括号[]内元素)进行操作时，由浅复制得到的dict**会**受该操作影响
  
  - `dict1[a]=3`不会影响到`dict2[a]`的值
  
  - `dict1[a].append(3)`会影响到`dict2[a]`的值

- `dict1=deepcopy(dict2)`，这个是深复制：复制后对原dict的内部子对象(方括号[]内元素)进行操作时，由深复制得到的dict**不会**受该操作影响
  
  - `dict1[a]=3`不会影响到`dict2[a]`的值
  
  - `dict1[a].append(3)`不会影响到`dict2[a]`的值

- [x] python的sortedlist怎么使用？

一个demo

```python
from sortedcontainers import SortedList
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:

        n = len(nums)
        res = [0] * n
        sl = SortedList()

        for i in range(n-1, -1, -1):        # 反向遍历
            cnt = sl.bisect_left(nums[i])   # 找到右边比当前值小的元素个数
            res[i] = cnt                    # 记入答案
            sl.add(nums[i])                 # 将当前值加入有序数组中

        return res
```
